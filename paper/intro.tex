Database systems use memory buffers to retain some number of pages for a while after they've been read from the disk. That way, if the DBMS needs the same page again and it is in memory buffer, it can save one access to disk. The question is, when the buffer is full and we need to put another page in, which page should we drop from the buffer? One popular algorithm to determine the page to drop is Least Recently Used (LRU). With LRU, the buffer drops the page that was used least recently.

In 1993, O'Neil et al. \cite{lruk} developed an extension to LRU algorithm called LRU-K. The basic idea of LRU-K is to use last K references of the page and drop the page with least recent Kth reference in the past. With $K = 1$, the algorithm is equivalent to the classic LRU algorithm.

To better adapt LRU-K to real-world database workloads and address some of the unrealistic assumptions made by the initial algorithm, O'Neil et al. propose the Correlated Reference Period (CRP), which is a time-out period that dealt with two significant performance issues caused by LRU-K (known as the \emph{early page replacement} and \emph{correlated references}). Early page replacement occurs when a page has been accessed less than k times and thus has the largest backward distance at the time of choosing a replacement victim; the CRP method automatically retains this page if its last access time is within the time-out period. The problem of correlated references occurs when a page was accessed multiple times by the same query or process in a short span of time, the CRP method collapses all references to a single page within the time-out period into one reference.

In their paper, O'Neil et al. propose a hypothesis that LRU-2 and LRU-3 outperform LRU-1. They also hypothesize that LRU-3 is only slightly better than LRU-2 and propose using LRU-2 because of the slower adaptation of LRU-3 to evolving access patterns. As a proxy to prove their hypotheses, they evaluated LRU-K on three different workloads - two pool, zipfian and OLTP trace.

We recreate their first two experiments - two pool and zipfian. As a third experiment, we use a trace from instrumented PostgreSQL running \texttt{pgbench}. Our results in all three experiments support both of their hypotheses.

We organize this paper as follows. In section \ref{sec:method} we discuss our experiment protocol and methodology. In section \ref{sec:results} we present our results and in section \ref{sec:conc} we conclude.
